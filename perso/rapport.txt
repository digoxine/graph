Exercice 2:
Les fichiers se trouvent dans adjarray.c. adjarray.c permet de lire le fichier pour remplir la structure adjlist.
À chaque fois qu'un noeud est lu dans notre fichier, nous incrémentons n.
Pour le fichier Amazon, nous constatons que nous avons :
548552 noeuds ainsi que 925872 arêtes.

Exercice 3:
Nous utilisons la ligne de commande suivante qui nous permet de supprimer les doubles arcs:
awk '{if ($1<$2) print $1" "$2;else if ($2<$1) print $2" "$1}' net.txt | sort -n -k1,2 -u > net2.txt
Il est important de supprimer la première en commentaire afin que les lignes soient lues et mises en mémoire.
A l'issue de cette commande, nous avons quelque chose de la forme :
n1 n2

Exercice 4:

Pour stocker notre graph à l'intérieur d'une liste d'adjacence, nous utilisons les structures suivantes :
typedef struct {
	unsigned long s;
	unsigned long t;
} edge;

//edge list structure:
typedef struct {
	unsigned long n;//nombre de noeuds
	unsigned long e;//nombre d'arêtes
	edge *edges;//liste d'arêtes
	unsigned long *cd;//degre cumulatif chaque case est la somme de la précedente plus le degré du noeud actuel
	unsigned long *adj;//Liste d'adjacence compactée. Elle ne contiendra qu'un array de unsigned long. Pour un noeud i, tous ses voisins seront contenus entre cd[i] et cd[i+1]
} adjlist;


Pour la lecture de notre fichier :

     Tout d'abord, nous créons notre structure adjlist g.
On alloue notre edges avec le nombre de liens.
on stocke l'arête de la ligne avec s et t.
On met à jour n le nombre de noeuds de notre structure avec le maximum de tous les noeuds déjà rencontrés.
On incrémente g->e.

Pour la construction de liste d'adjacence:
     Tout d'abord nous allouons un tableau de taille notre de noeuds de notre structure.
     Ce tableau contiendra tous les degrés de chaque noeud.

     Nous parcourons chaque arête et nous incrémentons le degré des noeuds correspondants.
     Nous allouons ensuite le tableau des degrés cummulatifs de taille n+1 car nous commencons à 0.
     Chaque case correspondra à la dernière case de cd + le degré du sommet en cours.

     Nous créons ensuite notre liste d'adjacence à proprement parlé.
     Comme le graph est non orienté, nous devons allouer 2 fois le nomber d'arcs car les tous les voisins de u contiennent v et tous les voisins de v contiennent u.
     Puis nous construisons notre liste d'adjacence en utilisant les degrés qui seront incrémentés à chaque fois que nous rencontrons un voisin de u. Nous agirons de la même manière pour v.


adjarray et edgelist prennent moins d'une seconde pour être exécutée pour tous les fichiers txt.

En revanche, pour ce qui est de adjmatrix, j'obtiens un segmentation fault dès lors que j'essaye de rentrer en mémoire les gros fichiers.
Le fichier email contenant à 1002 noeuds ainsi que mes tests de tailles plus modestes s'exécutent correctement et prennent moins d'une seconde à être exécutée.

Exercice 5:

Pour avoir le diametre on s'interesse à la composante connexe la plus grande. Sinon le diamètre serait infini.
Une fois que nous avons trouvé le plus petit sommet appartenant à la plus grande composante connexe.
Nous mettons à jour un vecteur visit qui servira à stocker tous les sommets rencontrables dans notre composante connexe.
Pour ce qui est du coeur de notre algorithme pour déterminer le diamètre, nous définissons un N_DIAMETER arbitrère tel que nous ferons n fois la boucle suivante:
-Tout d'abord, nous prenons un noeud au hasard de notre composante connexe.
-Nous recueillerons le résultat de max_chemin_djikstra qui agit de la même manière que BFS mais en incrémentant un vecteur distance qui contient toutes les distances minimales pour aller du noeud u vers tous les noeuds.
La fonction max_chemin_djikstra calculera en plus de ce qui est dit précedemment, la distance maximale entre u et un certain noeud et renverra la valeur.
-il est demandé une lower bound donc nous prenons le minimum des diamètres obtenus sur nos N_DIAMETER incrémentation.

Il est important de préciser que notre algorithme n'est pas déterministe.
Si nous voulions l'être nous serions obligé de faire une boucle sur tous les sommets de notre composante connexe de taille maximale.
Admettons que nous ayons une seule et unique composante connexe contenant un nombre faramineux de sommets.
Alors nous aurions dû effectuer cet algoritme n fois.
Ce qui majore considérablement les temps d'exécution de notre programme.
L'approche que nous avons choisi d'utiliser permet de réduire considérablement ces temps d'exécution même si elle perd en fiabilité.
Nous allons déterminer dans la partie expérimentale si nos résultats sont satisfaisants.

Partie expérimentale:

J'ai pu effectuer des tests sur un graph personnalisé de taille plus modeste.
Nous avons le graphe suivant:
10 11
0 1
1 3
1 4
2 5
2 3
3 4
4 2
2 6
8 3
6 8
7 9

L'algorithme diameter renvoie bien la bonne valeur du diamètre à savoir 2.

J'ai aussi pu effectuer le test sur le graphe suivant:

0 1
2 3
2 6
3 6
4 5
5 6
6 4
7 8
8 9
9 7
Le programme renvoie bien 1 ce qui est une valeur correcte.


Pour ce qui est du fichier amazon, j'obtiens les résultats suivants:
Nous trouvons un diamètre de 9.

Fichier email:
Diamètre 13.

Fichier lj:
Diamètre 224.
46 minutes tout de même.

Fichier orkut:
Diamètre 267.
